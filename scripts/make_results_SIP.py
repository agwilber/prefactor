#!/usr/bin/env python

import os,sys
import siplib
import feedback
import time
import get_MOM_data as MOM

def input2bool(invar):
    if invar == None:
        return None
    if isinstance(invar, bool):
        return invar
    elif isinstance(invar, str):
        if invar.upper() == 'TRUE' or invar == '1':
            return True
        elif invar.upper() == 'FALSE' or invar == '0':
            return False
        else:
            raise ValueError('input2bool: Cannot convert string "'+invar+'" to boolean!')
    elif isinstance(invar, int) or isinstance(invar, float):
        return bool(invar)
    else:
        raise TypeError('input2bool: Unsupported data type:'+str(type(invar)))

def read_matching_file(matchfile):
    """
    Reads in the match-file generated by sort_times_into_freqGroups.py
    """
    file_matching = {}
    with open(matchfile) as f:
        for line in f:
            parts = line.strip().split()
            file_matching[parts[0]] = parts[1:]
    return file_matching


def get_dataproducts_from_feedback(infile):
    """
    Reads in the pseudo feedback file given as input and returns a list of dataproducts.
    """
    dataproducts = []
    with open(infile) as f:
        text = f.readlines()
        FBdata = feedback.Feedback(text)
        prefix = text[0].split('.')[0]
        dataproducts = FBdata.get_dataproducts(prefix=prefix)
    return dataproducts


def main(matchfile, results_feedback, verbose = False, fail_on_error = True):
    """
    Generate SIP files for all files mentioned in "results_feedback"
    The corresponding input files are taken from "matchfile"

    matchfile : str , path
      Path to the match-file generated by sort_times_into_freqGroups.py 
    results_feedback : str , path
      Path to the feedback file for the pipeline results, generated by the 
      get_metadata recipe.
    verbose : bool, (str with bool value)
      Print more output.
    fail_on_error : bool, (str with bool value)
      Stop processing if a recoverable error occurs in one file.
    """
    file_matching = read_matching_file(matchfile)
    pipeline_products = get_dataproducts_from_feedback(results_feedback)
    verbose = input2bool(verbose)
    fail_on_error = input2bool(fail_on_error)
    for product in pipeline_products:
        product_name = product.get_pyxb_dataproduct().fileName
        if product_name not in file_matching:
            print "make_results_SIP: Could not find file \"%s\" in matching list."%(product_name)
            if fail_on_error:
                raise ValueError("make_results_SIP: Could not find a file in matching list")
            else:
                continue
        mom_sip = MOM.get_SIP_from_MSfile(file_matching[product_name][0], verbose=verbose)        
        newsip = siplib.Sip(
            project_code=mom_sip.sip.project.projectCode,
            project_primaryinvestigator=mom_sip.sip.project.primaryInvestigator,
            project_contactauthor=mom_sip.sip.project.contactAuthor,
            #project_telescope="LOFAR",
            project_description=mom_sip.sip.project.projectDescription,
            project_coinvestigators=mom_sip.sip.project.coInvestigator,
            dataproduct = product
        )
        newsip.add_observation(mom_sip.sip.observation[0])
        newsip.add_related_dataproduct_with_history(mom_sip)
        for input in file_matching[product_name][1:]:
            mom_sip = MOM.get_SIP_from_MSfile(input, verbose=verbose)
            newsip.add_related_dataproduct_with_history(mom_sip)
        
        newsip.getprettyxml()
        newsip.save_to_file('example-sip.xml')
        if verbose:
            import visualizer
            visualizer.visualize_sip(newsip, path="example-sip.visualization")


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Generate the SIP-files for the result MSs from Pre_Facet_Cal.')

    parser.add_argument('ResultsFeedback', type=str, 
                        help='"Pseudo feedback file for the result MSs. One SIP file will be generated for '
                        'each dataproduct in this file.')

    parser.add_argument('Matchfile', type=str,                         
                        help='File matching the pipeline results to the input files. '
                        'Usually generated by \"sort_times_into_freqGroups.py\".')

    args = parser.parse_args()

    results_file = args.ResultsFeedback
    match_file = args.Matchfile

    main(match_file, results_file, verbose = True, fail_on_error = False)


########################################## old stuff, that I don't want to remove yet. !!!


def match_dataproducts(results_list, input_list):
    """
    Mates dataproducts from input_list to those in results_list.

    An input dataproduct from matches an output dataproduct if:
    - the centralFrequency of the input is within the bandwitdh on the result
      (bandwidth = centralFrequency +/- channelsPerSubband * channelWidth / 2.)
    - the startTime of the result is not before the startTime of the input and
      before "startTime + duration" of the input 
    """
    print "Matching %d result files and %d input files"%(len(results_list), len(input_list))

    input_freqs       = []
    input_start_times = []
    input_end_times   = []
    for dataprod in input_list:
        input_freqs.append( dataprod.get_pyxb_dataproduct().centralFrequency.value() )
        input_start_times.append( time.mktime(dataprod.get_pyxb_dataproduct().startTime.timetuple()) )
        input_end_times.append( time.mktime((dataprod.get_pyxb_dataproduct().startTime+dataprod.get_pyxb_dataproduct().duration).timetuple()) )
    
    matched_list = []
    for result in results_list:
        bw = result.get_pyxb_dataproduct().channelsPerSubband*result.get_pyxb_dataproduct().channelWidth.value()
        start_freq = result.get_pyxb_dataproduct().centralFrequency.value() - bw/2.
        end_freq = result.get_pyxb_dataproduct().centralFrequency.value() + bw/2.
        start_time = time.mktime(result.get_pyxb_dataproduct().startTime.timetuple())
        match_this = []
        for idx in xrange(len(input_list)):
            if (input_freqs[idx] >= start_freq and input_freqs[idx] < end_freq and 
                input_start_times[idx] <= start_time and input_end_times[idx] > start_time ):
                match_this.append(input_list[idx])
        if len(match_this) == 0:
            print 'Did not find matching input files for:',result.get_pyxb_dataproduct().fileName
        matched_list.append(match_this)
    return matched_list
